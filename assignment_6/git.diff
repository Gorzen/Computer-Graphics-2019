diff --git a/opengl/src/earth.frag b/opengl/src/earth.frag
index f501261..6eba1da 100644
--- a/opengl/src/earth.frag
+++ b/opengl/src/earth.frag
@@ -27,5 +27,64 @@ const vec3  sunlight = vec3(1.0, 0.941, 0.898);
 
 void main()
 {
-  
+  /**
+  *  Implement the Phong shading model (like in the 1st exercise) by using the passed
+  *  variables and write the resulting color to `color`.
+  *  `tex` should be used as material parameter for ambient, diffuse and specular lighting.
+  * Hints:
+  * - The texture(texture, 2d_position) returns a 4-vector (rgba). You can use
+  * `texture(...).r` to get just the red component or `texture(...).rgb` to get a vec3 color
+  * value
+   */
+  vec3 color = vec3(0.0,0.0,0.0);
+  vec3 cloud_color = vec3(0.0,0.0,0.0);
+
+  vec4 v_day = texture(day_texture, v2f_texcoord);
+  vec4 v_night = texture(night_texture, v2f_texcoord);
+  vec4 v_cloud = texture(cloud_texture, v2f_texcoord);
+  vec4 v_gloss = texture(gloss_texture, v2f_texcoord);
+
+  vec3 I_l = sunlight;
+  vec3 I_a = 0.2 * sunlight;
+
+  vec3 m_a_day = v_day.rgb;
+  vec3 m_d_day = v_day.rgb;
+  vec3 m_s_day = vec3(1,1,1);
+  vec3 m_a_night = v_night.rgb;
+  float spec_value = v_gloss.r;
+  float cloud_val = v_cloud.r;
+
+  float n_dot_l = dot(v2f_normal, v2f_light);
+  float n_dot_l_mapped = (n_dot_l + 1)/2.0;
+
+  //Cloud ambiant color
+  vec3 m_cloud = vec3(cloud_val, cloud_val, cloud_val);
+  cloud_color += I_a * m_cloud * n_dot_l;
+
+  //Ambiant
+  color += I_a * m_a_day * n_dot_l_mapped + m_a_night * (1 - n_dot_l_mapped);
+
+  if (n_dot_l > 0) {
+    //Diffuse
+    color += I_l * m_d_day * n_dot_l;
+    cloud_color += I_l * m_cloud * n_dot_l;
+
+    vec3 mirrored = (2.0 * dot(v2f_normal, v2f_light)) * v2f_normal - v2f_light;
+
+    float r_dot_v = dot(mirrored, v2f_view);
+
+    //Specular
+    if (r_dot_v < 0) {
+      color += I_l * m_s_day * pow(r_dot_v, shininess) * spec_value * (1 - cloud_val);
+    }
+  }
+
+  //Linear interpolation between cloud and phong
+  color = color * (1 - cloud_val) + cloud_color * cloud_val;
+
+  // convert RGB color to YUV color and use only the luminance
+  if (greyscale) color = vec3(0.299*color.r+0.587*color.g+0.114*color.b);
+
+  // add required alpha value
+  f_color = vec4(color, 1.0);
 }
diff --git a/opengl/src/earth.vert b/opengl/src/earth.vert
index 22a3024..cb29177 100644
--- a/opengl/src/earth.vert
+++ b/opengl/src/earth.vert
@@ -29,4 +29,13 @@ uniform vec4 light_position; //in eye space coordinates already
 void main()
 {
 
+  v2f_texcoord = v_texcoord;
+  v2f_normal = normalize(normal_matrix * v_normal);
+  v2f_light = normalize(light_position.rgb);
+
+  vec4 view4 = modelview_matrix * v_position;
+  v2f_view = normalize(view4.rgb);
+
+  gl_Position = modelview_projection_matrix * v_position;
+
 }
diff --git a/opengl/src/phong.frag b/opengl/src/phong.frag
index 3e212fe..0819a02 100644
--- a/opengl/src/phong.frag
+++ b/opengl/src/phong.frag
@@ -24,9 +24,40 @@ const vec3  sunlight = vec3(1.0, 0.941, 0.898);
 
 void main()
 {
-
+    /**
+    *  Implement the Phong shading model (like in the 1st exercise) by using the passed
+    *  variables and write the resulting color to `color`.
+    *  `tex` should be used as material parameter for ambient, diffuse and specular lighting.
+    * Hints:
+    * - The texture(texture, 2d_position) returns a 4-vector (rgba). You can use
+    * `texture(...).r` to get just the red component or `texture(...).rgb` to get a vec3 color
+    * value
+     */
     vec3 color = vec3(0.0,0.0,0.0);
 
+    vec4 v_texture = texture(tex, v2f_texcoord);
+
+    vec3 I_l = sunlight;
+    vec3 I_a = 0.2 * sunlight;
+    vec3 m_a = v_texture.rgb;
+    vec3 m_d = v_texture.rgb;
+    vec3 m_s = v_texture.rgb;
+
+    color += I_a * m_a;
+
+    float n_dot_l = dot(v2f_normal, v2f_light);
+    if (n_dot_l > 0) {
+      color += I_l * m_d * n_dot_l;
+
+      vec3 mirrored = (2.0 * dot(v2f_normal, v2f_light)) * v2f_normal - v2f_light;
+
+      float r_dot_v = dot(mirrored, v2f_view);
+
+      if (r_dot_v < 0) {
+        color += I_l * m_s * pow(r_dot_v, shininess);
+      }
+    }
+
     // convert RGB color to YUV color and use only the luminance
     if (greyscale) color = vec3(0.299*color.r+0.587*color.g+0.114*color.b);
 
diff --git a/opengl/src/phong.vert b/opengl/src/phong.vert
index 56614c6..0861e2f 100644
--- a/opengl/src/phong.vert
+++ b/opengl/src/phong.vert
@@ -24,9 +24,22 @@ uniform mat4 modelview_matrix;
 uniform mat3 normal_matrix;
 uniform vec4 light_position; //in eye space coordinates already
 
-
-
 void main()
 {
+  /** \todo Setup all outgoing variables so that you can compute in the fragmend shader
+    the phong lighting. You will need to setup all the uniforms listed above, before you
+    can start coding this shader.
+
+    Hint: Compute the vertex position, normal and light_position in eye space.
+    Hint: Write the final vertex position to gl_Position
+  */
+
+  v2f_texcoord = v_texcoord;
+  v2f_normal = normalize(normal_matrix * v_normal);
+  v2f_light = normalize(light_position.rgb);
+
+  vec4 view4 = modelview_matrix * v_position;
+  v2f_view = normalize(view4.rgb);
 
+  gl_Position = modelview_projection_matrix * v_position;
 }
diff --git a/opengl/src/solar_viewer.cpp b/opengl/src/solar_viewer.cpp
index 5089c65..0305a1b 100644
--- a/opengl/src/solar_viewer.cpp
+++ b/opengl/src/solar_viewer.cpp
@@ -403,12 +403,16 @@ void Solar_viewer::paint()
     }
     mat4    view = mat4::look_at(vec3(eye), vec3(center), vec3(up));
 
-    /** \todo Orient the billboard used to display the sun's glow
-     *  Update billboard_x_andle_ and billboard_y_angle_ so that the billboard plane
-     *  drawn to produce the sun's halo is orthogonal to the view vector for
-     *  the sun's center.
-     */
-    billboard_x_angle_ = billboard_y_angle_ = 0.0f;
+  /** \todo Orient the billboard used to display the sun's glow
+    *  Update billboard_x_andle_ and billboard_y_angle_ so that the billboard plane
+    *  drawn to produce the sun's halo is orthogonal to the view vector for
+    *  the sun's center.
+    */
+
+    vec3 direction = normalize(vec3(eye[0], eye[1], eye[2]));
+
+    billboard_x_angle_ = asin(-direction[1]) * 180.0/M_PI;
+    billboard_y_angle_ = atan2(direction[0], direction[2]) * 180.0/M_PI;
 
     mat4 projection = mat4::perspective(fovy_, (float)width_/(float)height_, near_, far_);
     draw_scene(projection, view);
@@ -468,21 +472,33 @@ void Solar_viewer::draw_scene(mat4& _projection, mat4& _view)
      m_matrix = mat4::translate(earth_.pos_) * mat4::rotate_y(earth_.angle_self_) * mat4::scale(earth_.radius_);
      mv_matrix = _view * m_matrix;
      mvp_matrix = _projection * mv_matrix;
-     color_shader_.use();
-     color_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
-     color_shader_.set_uniform("greyscale", (int)greyscale_);
-     color_shader_.set_uniform("tex", 0);
+     earth_shader_.use();
+     earth_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
+     earth_shader_.set_uniform("modelview_matrix", mv_matrix);
+     earth_shader_.set_uniform("normal_matrix", inverse(transpose(mat3(mv_matrix))));
+     earth_shader_.set_uniform("light_position", light);
+     earth_shader_.set_uniform("greyscale", (int)greyscale_);
+     earth_shader_.set_uniform("day_texture", 0);
+     earth_shader_.set_uniform("night_texture", 1);
+     earth_shader_.set_uniform("cloud_texture", 2);
+     earth_shader_.set_uniform("gloss_texture", 3);
      earth_.tex_.bind();
+     earth_.night_.bind();
+     earth_.cloud_.bind();
+     earth_.gloss_.bind();
      unit_sphere_.draw();
 
      //Draw mercury
      m_matrix = mat4::translate(mercury_.pos_) * mat4::rotate_y(mercury_.angle_self_) * mat4::scale(mercury_.radius_);
      mv_matrix = _view * m_matrix;
      mvp_matrix = _projection * mv_matrix;
-     color_shader_.use();
-     color_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
-     color_shader_.set_uniform("greyscale", (int)greyscale_);
-     color_shader_.set_uniform("tex", 0);
+     phong_shader_.use();
+     phong_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
+     phong_shader_.set_uniform("modelview_matrix", mv_matrix);
+     phong_shader_.set_uniform("light_position", light);
+     phong_shader_.set_uniform("normal_matrix", inverse(transpose(mat3(mv_matrix))));
+     phong_shader_.set_uniform("greyscale", (int)greyscale_);
+     phong_shader_.set_uniform("tex", 0);
      mercury_.tex_.bind();
      unit_sphere_.draw();
 
@@ -490,21 +506,25 @@ void Solar_viewer::draw_scene(mat4& _projection, mat4& _view)
      m_matrix = mat4::translate(mars_.pos_) * mat4::rotate_y(mars_.angle_self_) * mat4::scale(mars_.radius_);
      mv_matrix = _view * m_matrix;
      mvp_matrix = _projection * mv_matrix;
-     color_shader_.use();
-     color_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
-     color_shader_.set_uniform("greyscale", (int)greyscale_);
-     color_shader_.set_uniform("tex", 0);
+     phong_shader_.use();
+     phong_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
+     phong_shader_.set_uniform("modelview_matrix", mv_matrix);
+     phong_shader_.set_uniform("normal_matrix", inverse(transpose(mat3(mv_matrix))));
+     phong_shader_.set_uniform("greyscale", (int)greyscale_);
+     phong_shader_.set_uniform("tex", 0);
      mars_.tex_.bind();
      unit_sphere_.draw();
 
      //Draw venus
-     m_matrix = mat4::translate(venus_.pos_) * mat4::rotate_y(venus_.angle_self_) * mat4::scale(venus_.radius_);
+     m_matrix =  mat4::translate(venus_.pos_) * mat4::rotate_y(venus_.angle_self_) * mat4::scale(venus_.radius_);
      mv_matrix = _view * m_matrix;
      mvp_matrix = _projection * mv_matrix;
-     color_shader_.use();
-     color_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
-     color_shader_.set_uniform("greyscale", (int)greyscale_);
-     color_shader_.set_uniform("tex", 0);
+     phong_shader_.use();
+     phong_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
+     phong_shader_.set_uniform("modelview_matrix", mv_matrix);
+     phong_shader_.set_uniform("normal_matrix", inverse(transpose(mat3(mv_matrix))));
+     phong_shader_.set_uniform("greyscale", (int)greyscale_);
+     phong_shader_.set_uniform("tex", 0);
      venus_.tex_.bind();
      unit_sphere_.draw();
 
@@ -520,13 +540,15 @@ void Solar_viewer::draw_scene(mat4& _projection, mat4& _view)
      unit_sphere_.draw();
 
      //Draw moon
-     m_matrix = mat4::translate(moon_.pos_) * mat4::rotate_y(moon_.angle_self_) * mat4::scale(moon_.radius_);
+     m_matrix = mat4::translate(moon_.pos_) * mat4::rotate_y(moon_.angle_self_) * mat4::rotate_y(-moon_.angle_orbit_) * mat4::scale(moon_.radius_);
      mv_matrix = _view * m_matrix;
      mvp_matrix = _projection * mv_matrix;
-     color_shader_.use();
-     color_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
-     color_shader_.set_uniform("greyscale", (int)greyscale_);
-     color_shader_.set_uniform("tex", 0);
+     phong_shader_.use();
+     phong_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
+     phong_shader_.set_uniform("modelview_matrix", mv_matrix);
+     phong_shader_.set_uniform("normal_matrix", inverse(transpose(mat3(mv_matrix))));
+     phong_shader_.set_uniform("greyscale", (int)greyscale_);
+     phong_shader_.set_uniform("tex", 0);
      moon_.tex_.bind();
      unit_sphere_.draw();
 
@@ -541,6 +563,29 @@ void Solar_viewer::draw_scene(mat4& _projection, mat4& _view)
      ship_.tex_.bind();
      ship_.draw();
 
+     /** \todo Render the sun's halo here using the "color_shader_"
+     *   - Construct a model matrix that scales the billboard to 3 times the
+     *     sun's radius and orients it according to billboard_x_angle_ and
+     *     billboard_y_angle_
+     *   - Bind the texture for and draw sunglow_
+     **/
+
+     //Draw billboard
+     m_matrix = mat4::rotate_y(billboard_y_angle_) * mat4::rotate_x(billboard_x_angle_) * mat4::scale(1.85);
+     mv_matrix = _view * m_matrix;
+     mvp_matrix = _projection * mv_matrix;
+     color_shader_.use();
+     color_shader_.set_uniform("modelview_projection_matrix", mvp_matrix);
+     color_shader_.set_uniform("greyscale", (int)greyscale_);
+     color_shader_.set_uniform("tex", 0);
+     sunglow_.tex_.bind();
+
+     glEnable(GL_BLEND);
+     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+     sunglow_.draw();
+
+     glDisable(GL_BLEND);
 
      /** \todo Switch from using color_shader_ to the fancier shaders you'll
       * implement in this assignment:
@@ -552,14 +597,7 @@ void Solar_viewer::draw_scene(mat4& _projection, mat4& _view)
       *  matrix, and light position in addition to the color_shader_ parameters.
       */
 
-     /** \todo Render the sun's halo here using the "color_shader_"
-     *   - Construct a model matrix that scales the billboard to 3 times the
-     *     sun's radius and orients it according to billboard_x_angle_ and
-     *     billboard_y_angle_
-     *   - Bind the texture for and draw sunglow_
-     **/
 
-     
     // check for OpenGL errors
     glCheckError();
 }
diff --git a/opengl/src/texture.cpp b/opengl/src/texture.cpp
index 6b72412..5f301f6 100644
--- a/opengl/src/texture.cpp
+++ b/opengl/src/texture.cpp
@@ -12,6 +12,8 @@
 #include <cassert>
 #include <algorithm>
 #include "lodepng.h"
+#include <stdio.h>
+#include <math.h>
 
 //=============================================================================
 
@@ -100,12 +102,33 @@ bool Texture::createSunBillboardTexture()
     int height = 900;
     img.resize(width*height * 4);
 
+    /** \todo Set up the texture for the sun billboard.
+    *   - Draw an opaque circle with a 150 pixel radius in its middle
+    *   - Outside that circle the texture should become more and more transparent to mimic a nice glow effect
+    *   - Make sure that your texture is fully transparent at its borders to avoid seeing visible edges
+    *   - Experiment with the color and with how fast you change the transparency until the effect satisfies you
+    **/
+
     for (int col = 0; col < width; ++col) {
         for (int row = 0; row < height; ++row) {
-            img[(row * width + col) * 4 + 0] = 255; // R
-            img[(row * width + col) * 4 + 1] = 255; // G
-            img[(row * width + col) * 4 + 2] = 255; // B
-            img[(row * width + col) * 4 + 3] = 255; // A
+
+            int x = abs(row - height/2);
+            int y = abs(col - width/2);
+
+            float distance = std::sqrt(x * x + y * y);
+
+            int alpha;
+
+            if(distance <= 150){
+              alpha = 255;
+            } else {
+              alpha =  std::max(0, (int)(-(distance - 150)*255/300 + 255));
+            }
+
+            img[(row * width + col) * 4 + 0] = 252; // R
+            img[(row * width + col) * 4 + 1] = std::min(200, alpha); // G
+            img[(row * width + col) * 4 + 2] = 50; // B
+            img[(row * width + col) * 4 + 3] = alpha; // A
         }
     }
 
